import logging
import json
import os
from dataclasses import dataclass, asdict, field
from datetime import datetime
from typing import List, Optional, Dict, Any

from dotenv import load_dotenv
from livekit.agents import (
    Agent,
    AgentSession,
    JobContext,
    JobProcess,
    MetricsCollectedEvent,
    RoomInputOptions,
    WorkerOptions,
    cli,
    metrics,
    tokenize,
    function_tool,
    RunContext
)
from livekit.plugins import murf, silero, google, deepgram, noise_cancellation
from livekit.plugins.turn_detector.multilingual import MultilingualModel

logger = logging.getLogger("agent")

# --- Configuration ---
load_dotenv(".env.local")
LOG_FILE = "wellness_log.json"

# --- 1. DEFINE LOG ENTRY STATE ---


@dataclass
class CheckinLogEntry:
    """The data structure for a single daily check-in."""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    mood_summary: Optional[str] = None
    energy_level: Optional[str] = None
    objectives: List[str] = field(default_factory=list)
    agent_summary: Optional[str] = None

# --- Persistence Functions ---


def _load_log() -> List[Dict[str, Any]]:
    """Loads the wellness log from the JSON file."""
    if not os.path.exists(LOG_FILE):
        return []
    try:
        with open(LOG_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        logger.warning(
            f"Could not read or parse {LOG_FILE}. Starting a new log.")
        return []


def _save_entry(entry: CheckinLogEntry):
    """Saves a new entry to the wellness log file."""
    log = _load_log()
    log.append(asdict(entry))
    with open(LOG_FILE, 'w') as f:
        json.dump(log, f, indent=4)
    logger.info(f"New check-in logged to {LOG_FILE}")

# --- 2. DEFINE THE LOGGING TOOL ---


@function_tool
async def log_checkin(
    context: RunContext,
    mood_summary: Optional[str] = None,
    energy_level: Optional[str] = None,
    objectives: Optional[List[str]] = None,
    agent_summary: Optional[str] = None,
) -> str:
    """
    Called when the daily check-in is complete to persist the results.
    Use this tool once the agent has captured the user's mood, energy, and objectives.

    Args:
        mood_summary: A short description of the user's overall mood (e.g., 'stressed but hopeful').
        energy_level: The user's self-reported energy level (e.g., 'low', 'medium', 'high').
        objectives: A list of 1-3 concrete goals or intentions for the day.
        agent_summary: A brief summary sentence generated by the agent for the recap.
    """

    # 1. Create the new log entry
    new_entry = CheckinLogEntry(
        mood_summary=mood_summary,
        energy_level=energy_level,
        objectives=objectives if objectives else [],
        agent_summary=agent_summary
    )

    # 2. Save the entry to the JSON file
    _save_entry(new_entry)

    # 3. Send data to frontend for visualization
    try:
        await context.room.local_participant.publish_data(
            json.dumps({
                "type": "CHECKIN_COMPLETE",
                "entry": asdict(new_entry)
            }).encode('utf-8'),
            topic="checkin_complete"
        )
        logger.info("Check-in data sent to frontend")
    except Exception as e:
        logger.error(f"Failed to send check-in data: {e}")

    # 4. Formulate the final recap message
    obj_list = ", ".join(new_entry.objectives) if new_entry.objectives else "no specific goals"

    return (
        f"LOGGING COMPLETE. Confirmation: Your mood summary is '{new_entry.mood_summary}', "
        f"energy level is '{new_entry.energy_level}', "
        f"and your main objectives are: {obj_list}. "
        f"Your log has been updated. Provide a final, supportive closing statement "
        f"and wish the user a successful day."
    )

# --- 3. DEFINE THE WELLNESS AGENT ---


class WellnessAgent(Agent):
    def __init__(self, llm, historical_context: str) -> None:

        # Craft a dynamic instruction set using historical data
        base_instructions = (
            "You are Kai, a supportive, non-clinical, and grounded health & wellness companion. "
            "Your goal is to conduct a short daily check-in, set 1-3 simple goals, and provide realistic encouragement. "
            "\n\n"
            "**GREETING:** Start every new session with: 'Good morning! I'm Kai, your wellness companion. How are you feeling today?'"
            "\n\n"
            "**CHECK-IN FLOW (Mandatory Steps):**\n"
            "1. Ask about **Mood and Energy** (e.g., 'How are you feeling today?' 'What's your energy like?').\n"
            "2. Ask about **Objectives/Intentions** for the day (1-3 small, actionable goals).\n"
            "3. Offer **Simple, Realistic Advice or Reflection** (e.g., break goals down, encourage short breaks, or offer a grounding idea).\n"
            "4. When all info is gathered (Mood, Energy, Objectives), call the **log_checkin tool IMMEDIATELY** to persist the data and get the final recap prompt.\n"
            "\n"
            "**RULES:**\n"
            "- AVOID all medical claims, diagnosis, or clinical terms. Stick to supportive language.\n"
            "- Keep responses brief, empathetic, and conversational.\n"
            "- Only ask for ONE piece of missing information at a time.\n"
            "- If the user provides a lot of info at once, call the tool with all arguments filled.\n"
            "- Generate a brief agent_summary (1 sentence) that captures the essence of the check-in before calling the tool.\n"
        )

        # Add historical context for personalization
        if historical_context:
            instructions = (
                f"{base_instructions}\n\n"
                f"**HISTORICAL CONTEXT for this user:**\n"
                f"{historical_context}\n"
                f"**USE THIS CONTEXT** to reference a previous check-in in your opening or a follow-up question. "
                f"Example: 'Last time we talked, you mentioned finding energy low. How does today compare?'"
            )
        else:
            instructions = base_instructions

        super().__init__(
            instructions=instructions,
            tools=[log_checkin],
            llm=llm
        )


def prewarm(proc: JobProcess):
    """Loads the VAD model once per worker process."""
    proc.userdata["vad"] = silero.VAD.load()

# --- 4. ENTRYPOINT WITH PERSISTENCE LOGIC ---


async def entrypoint(ctx: JobContext):

    # 1. Load Historical Data for Context
    log = _load_log()
    historical_context = ""
    if log:
        # Get the most recent log entry
        latest_entry = log[-1]
        historical_context = (
            f"The user's last check-in ({latest_entry['timestamp'][:10]}): "
            f"Mood: '{latest_entry.get('mood_summary', 'N/A')}', "
            f"Energy: '{latest_entry.get('energy_level', 'N/A')}', "
            f"Objectives: {', '.join(latest_entry.get('objectives', [])) if latest_entry.get('objectives') else 'none set'}"
        )
        logger.info(f"Loaded historical context: {historical_context}")

    # 2. Setup LLM and Agent
    ctx.log_context_fields = {"room": ctx.room.name}
    llm = google.LLM(model="gemini-2.5-flash")
    agent_instance = WellnessAgent(
        llm=llm, historical_context=historical_context)

    # 3. Setup Voice AI Pipeline
    session = AgentSession(
        stt=deepgram.STT(model="nova-3"),
        llm=llm,
        tts=murf.TTS(
            voice="en-US-matthew",
            style="Conversation",
            tokenizer=tokenize.basic.SentenceTokenizer(min_sentence_len=2),
            text_pacing=True
        ),
        turn_detection=MultilingualModel(),
        vad=ctx.proc.userdata["vad"],
        preemptive_generation=True,
    )

    # 4. Metrics & Shutdown Setup
    usage_collector = metrics.UsageCollector()

    @session.on("metrics_collected")
    def _on_metrics_collected(ev: MetricsCollectedEvent):
        metrics.log_metrics(ev.metrics)
        usage_collector.collect(ev.metrics)

    async def log_usage():
        summary = usage_collector.get_summary()
        logger.info(f"Usage: {summary}")

    ctx.add_shutdown_callback(log_usage)

    # 5. Start the session
    await session.start(
        agent=agent_instance,
        room=ctx.room,
        room_input_options=RoomInputOptions(
            noise_cancellation=noise_cancellation.BVC(),
        ),
    )

    # 6. Join the room
    await ctx.connect()


if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))